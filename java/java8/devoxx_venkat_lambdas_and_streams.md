
# Get a Taste of Lambdas and Get Addicted to Streams by Venkat Subramaniam

URL: https://www.youtube.com/watch?v=1OpAgZvYXLQ&t

* [What is a Lambda Expression](#what-is-a-lambda-expression)
* [Using Lambda Expressions](#Using-lambda-expression)
* [How it fits into the Java Philosophy](#how-it-fits-into-the-java-philosophy)
* [What are Lambda expressions under the hood](#what-are-lambda-expressions-under-the-hood)
* [How this is going to change the way you code](#how-this-is-going-to-change-the-way-you-code)
* [A peek at method references](#a-peek-at-method-references)
  * [Same syntax for static method reference and instance method reference](#same-syntax-for-static-method-reference-and-instance-method-reference)
  * [Method references with 2 parameters](#method-references-with-2-parameters)
  * [Limitations of method references](#limitations-of-method-references)
* [Function composition](#function-composition)
* [Parallel Stream](#parallel-stream)
* [Caution points with parallel streams](#caution-points-with-parallel-streams)
* [Operations on stream](#operations-on-stream)
  * [filter](#filter)
  * [map](#map)
  * [reduce](#reduce)
    * [Special reduce functions](#special-reduce-functions)

## What is a Lambda Expression

The following is a very noisy code:

```java
package devoxx.java8.example;

public class Sample {
    public static void main(String[] args) throws InterruptedException {
        Thread th = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("In new thread");
            }
        });
        
        th.start();
        th.join();
        System.out.println("In main");
    }
}
```

Typically a function has 4 things:

* name
* parameter list
* body
* return type

The name and the return type don't have too much value, the name can be omitted and the return type can be inferred.

## Using Lambda Expression

So a lambda expresssion only have a parameter list and body.

The above code can be made less noisy in the following way:

```java
package devoxx.java8.example;

public class Sample {
    public static void main(String[] args) throws InterruptedException {
        Thread th = new Thread(() -> System.out.println("In new thread"));

        th.start();
        th.join();
        System.out.println("In main");
    }
}
```

We have parameter list to the left of the arrow (`->`) and the body of the method to the right of the arrow.

## How it fits into the Java Philosophy

Java has a central philosophy which is "backward compatibility".
You can simply pass a lambda in the thread constructor and it will simply work. You didn't have to change anything to use it with existing APIs.

Lambdas are backed by single abstract method interfaces. (like `Runnable`, `Callable`).
You can readily use lambdas where ever you see an interface that has single abstract method.

If the users of an API are divided between Java 7 and Java 8, then the users who are on Java 8 can simply pass lambdas and the users who are on Java 7 can pass anonymous inner classes. When the users who are using Java 7 move on to Java 8, they can readily pass lambdas. This is the beauty of backward compatibility.

## What are Lambda expressions under the hood

Are Lambda expressions nothing but syntactic sugar? Thechnically the answer to this is NO.

For each anonymous inner class the compiler will create a class like `Sample$1.class` which is generated by `javac`.

`invokedynamic` (in Java 7) - you can attach and detach the function that you want to invode at runtime. This gives you a callsite of function. You can also see this as function pointers are available at runtime at the program level.

under the hood - they use `invokedynamic` to implement lambdas. The use case for `invokedynamic` was to support lambda expression. (Though in Java 7 they were supposed to support the dynamically typed languages)

The lambda expressions, though they appear as a syntactic sugar over anonymous inner classes, they don't creat any anonymous innerclass.

Benefit: 

* This reduces the memory foot-print of jar
* Lesser number of objects will be created so lesser garbage collection overhead.

So a lambda expression don't get replaced by anonymous inner classes.

When you create a lambda expression, the call to the lambda expression becomes `invokedynamic`. You can use `javap Sample.class` and see this.

Lambda expression can become one of the 3 things:

* A static method
* An instance method
* Simple routing of the invodedynamic to some other method.

## How this is going to change the way you code

Transforming iterations from imperative to functional style

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // external iterators
        /*
         * you have complete control of the iteration
         *
         * this is not generally appear to be a good thing
         * the more you control, the more you have to change what you control
         *
         * The following code is very complex
         */
        for (int i = 0; i < nums.size(); i++) {
            System.out.println(nums.get(i));
        }

        // external iterator also
        for(int e : nums) {
            System.out.println(e);
        }

        // internal iterator
        /*
         * you are calling a method on the object itself
         *
         *
         * Polymorphism:
         * You can have different implementation based on
         * the exact type of the object
         *
         * you are not passing the list of numbers to for loop,
         * rather you are calling a method on the list object.
         *
         * this method can be sequential, parallel, lazy or whatever
         * depending on the implementation
         */
        nums.forEach(new Consumer<Integer>() {
            @Override
            public void accept(Integer integer) {
                System.out.println(integer);
            }
        });

        // replacing by lambda expression
        nums.forEach((Integer e) -> System.out.println(e));

        // replacing by lambda expression and removing obvious details
        /*
         * Java 8 has type inference for lambda expression
         *
         * no paranthesis
         *
         * paranthesis is optional (only for one parameter lambdas)
         * if a lambda has no parameter at all - you need to put paranthesis
         * if a lambda has 2 or more paramteres - you need to put paranthesis
         */
        nums.forEach(e -> System.out.println(e));

        /*
         * we are receiving a value and simply calling a method
         *
         * this is a simple pass through
         *
         * method reference syntax
         */
        nums.forEach(System.out::println);
    }
}
```

Word of caution:

* To keep the lambdas cute -> don't write 20 or 50 lines of code in lambda expression
* Lambda expression should be single line of code, ideally
  * Demerits of having multiple lines of code in Lambda expression
    * Hard to read
    * Noisy
    * leads to duplication
    * hard to test (you should not have logic in a lambda)
      * you should have a function (that you can unit-test properly) and then call this function from the lambda

## A peek at method references

You are receiving an argument as paramter, and you don't want to alter the arg, then you should use method-reference.

`System.out` is an object. And `println` is not a static method, rather it's an instance method.

* parameter as an argument
* parameter as an argument to a static method
* parameter as a target

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        nums.stream()
                .map(String::valueOf) // reference to a static method
                .forEach(System.out::println); // reference to an instance method
    }
}
```

### Same syntax for static method reference and instance method reference

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        nums.stream()
                .map(String::valueOf) // calling a static method
                .forEach(System.out::println);

        nums.stream()
                .map(e -> String.valueOf(e))
                .map(String::toString) // calling an instance method
                .forEach(System.out::println);

        /*
         * in the above 2 examples the syntax for calling static method
         * and instance method looks same
         *
         * So you will have to figure out that String::valueOf is static
         * and String::toString is instance method.
         *
         * But the beauty here is that both of them works seamlessly with
         * same syntax.
         */
    }
}
```

### Method references with 2 parameters

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // prints 55
        System.out.println(nums.stream()
                .reduce(0, (total, e) -> Integer.sum(total, e)));

        // prints 55
        System.out.println(nums.stream()
                .reduce(0, Integer::sum)); // both the elements are argument to Integer.sum
        // this is equivalent to calling Integer.sum(total, e)

        // prints 12345678910
        System.out.println(nums.stream()
                .map(String::valueOf)
                .reduce("", (result, e) -> result.concat(e))); // concatenating in ascending order
        // in this case one is target and one is argument

        // prints 12345678910
        System.out.println(nums.stream()
                .map(String::valueOf)
                .reduce("", String::concat));
        // same syntax as Integer::sum
        // (note that Integer.sum is static method ad String::concat is instance method)
        // still you are having the same syntax.

        // prints 10987654321
        System.out.println(nums.stream()
                .map(String::valueOf)
                .reduce("", (result, e) -> e.concat(result))); // concatenating in descending order
    }
}
```

CAUTION: the parameter order is important. (for sum it is not making any difference but for other methods it can give you worng results if the order is changed)

### Limitations of method references

* You cannot use them if you are doing any manipulation of the data
* You cannot use them if there is a conflict between instance method and static method (Example `Integer.toString()` is instance method and `Integer.toString(int)` is a static method - the compiler can't decide what to do here and gives you an error.)

## Function Composition

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;

public class Sample {
    public static void main(String[] args) throws InterruptedException {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Given numbers, double the even numbers and total them

        // imperative style code
        int result = 0;
        for (int e : nums) {
            if (e % 2 == 0)
                result += 2 * e;
        }
        System.out.println(result);

        // functional style code
        System.out.println(nums.stream()
                .filter(e -> e % 2 == 0)
                .map(e -> e * 2)
                .reduce(0, Integer::sum));

        // functional style code
        // the code is more expressive
        System.out.println(nums.stream()
                .filter(e -> e % 2 == 0)
                .mapToInt(e -> e * 2)
                .sum());
    }
}
```

## Parallel Stream

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;

public class Sample {
    public static void main(String[] args) throws Exception {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Given numbers, double the even numbers and total them

        Callable<Integer> runner = () ->
                nums.parallelStream()
                        .filter(e -> e % 2 == 0)
                        .mapToInt(Sample::compute)
                        .sum();
        System.out.println("execution time = " + TimeIt.timeIt(runner));
    }

    private static int compute(int x) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
        }
        return x * 2;
    }

    /**
     * A simple class that allows you to calculate execution time in milli-seconds
     */
    private static class TimeIt {
        private TimeIt() {
        }

        public static <T> double timeIt(Callable<T> callable) throws Exception {
            long start = System.nanoTime();
            System.out.println("result = " + callable.call());
            return (System.nanoTime() - start) / 1.0e6;
        }
    }
}
```

Output:

```bash
result = 60
execution time = 1014.36792
```

With parallel streams, the execution time is only approximately 1 second. But with non-parallel streams the execution time will go up to 5 seconds.

### Caution points with parallel streams

* Just because you have parallel streams, you should not use it every-where. (Be extremely careful when using it.)
* A parallel stream simply says that I don't mind using many threads and so I will use them.
* A very good example: Say you lost your mobile phone in a room and the room has `n` persons in it.
  * To find the phone, I can go sequentially to every person and ask him/her to find the mobile.
  * Or I can parallely ask every person in the room to find my phone parallely.
* If during the search the phone was found by the 5th person, then
  * Sequential search will give me result in 5 time-units, where 1 time unit is the time spent by one person
  * Parallel execution will give me the result in 1 time-unit.
* But keep in mind that the parallel execution is employing much greater amount of resources.

When you should use parallel streams:

* When the task at hand is parallelizable
* When you are willing to spend more resources
* When the data-set on which you are parallelizing is big enough, so that you get benefit in performance
* When the computation that you are having is big enough, so that you get benefit in performance

## Stream as Abstraction

A stream is not a physical object with data. A set is a data, collection is a data. But stream is not data. A stream is a bunch of functions that you will evaluate eventually. So there is no data sitting in stream. 

It is a non-mutating pipeline. Function composition is a pipeling, you are transforming the data in the pipeline but you are not mutating the data.

**Shared-mutability** - streams don't mutate data, rather they transform your data and returns the transformed data.

## Operations on Stream

### filter

* Blocks some data and lets some data pass through.
* number of ouptput: `0 <= number of elemnts in the output <= number of elemnts in the input`
* intput: `Stream<T>` filter takes `Predicate<T>`
* **Stay within it's swimlane**

### map

* transforms values of input stream into output stream
* number of output is equal to the number of input
* no gurantee on the type of output with respect to the type of input
* Parameter: `Stream<T>` map takes `Function<T, R>` and returns a `Stream<R>`
* **Stay within it's swimlane**

### reduce

* **cuts across the swimlanes**
* reduce a transform a collection into a single value or it may transform it to a non-stream or a concrete type.
* reduce takes an initial value
* reduce on `Stream<T>` takes 2 parameters. The first parameter is of type `T` and the second parameter is a `BiFunction<T, R>`. It returns a `Stream<R>`.

What are swimlanes?

|  | filter | map | reduce |
|:----:|:----:|:----:|:----:|
| x1 | / |  | \\ |
| x2 | -> | x2' | + |
| x3 | /|  | \\ |
| x4 | -> | x4' | + |
| x5 | -> | x5' | + |

* `/` means blocked
* `->` means not blocked
* `x2'`, `x4'` and `x5'` are the transformed values

#### Special reduce functions

* **sum**

    ```java
    package devoxx.java8.example;

    import java.util.Arrays;
    import java.util.List;

    public class Sample {
        public static void main(String[] args) throws Exception {
            List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

            // Given numbers, double the even numbers and total them
            double sum = nums.parallelStream()
                    .filter(e -> e % 2 == 0)
                    .mapToDouble(i -> i * 2.0)
                    .sum();
            System.out.println(sum);
        }
    }
    ```

* **collect**
  * `Collectors.toList()`
  * `Collectors.toSet`
  * consider the following code (it is badly written and you should never do this)

```java
package devoxx.java8.example;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Sample {
    public static void main(String[] args) throws Exception {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);

        // double the even values and put them in the list
        List<Integer> doubleOfEvens = new ArrayList<>();

        nums.stream()
                .filter(i -> i % 2 == 0)
                .map(i -> i * 2)
                .forEach(i -> doubleOfEvens.add(i));

        System.out.println(doubleOfEvens); // Don't do this
    }
}
```

* Reasons why the above code is bad
  * **Mutability is OK, sharing is nice, shared mutability is devil.**
  * **friends don't let friends do shared mutability.**
* Better way to do this:

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Sample {
    public static void main(String[] args) throws Exception {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);

        // double the even values and put them in the list
        List<Integer> doubleOfEvens = nums.stream()
                .filter(i -> i % 2 == 0)
                .map(i -> i * 2)
                .collect(Collectors.toList());

        System.out.println(doubleOfEvens);
    }
}

```

* Illustrating `Collectors.toSet()`

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class Sample {
    public static void main(String[] args) throws Exception {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 1, 2, 3, 4, 5);

        // double the even values and put them in the list
        Set<Integer> doubleOfEvens = nums.stream()
                .filter(i -> i % 2 == 0)
                .map(i -> i * 2)
                .collect(Collectors.toSet());

        System.out.println(doubleOfEvens);
    }
}
```

* Illustrating `Collectors.toMap()` and `Collectors.groupingBy()`

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class Sample {
    public static void main(String[] args) throws Exception {

        List<Person> people = createPeople();
        Map<String, Person> map = people.stream()
                .collect(Collectors.toMap(
                        person -> person.getName() + "-" + person.getAge(),
                        person -> person
                ));
        System.out.println(map);

        Map<String, List<Person>> nameMap = people.stream()
                .collect(Collectors.groupingBy(Person::getName));
        System.out.println(nameMap);
    }

    private static List<Person> createPeople() {
        return Arrays.asList(
                new Person("Sara", 20, Gender.FEMALE),
                new Person("Sara", 22, Gender.FEMALE),
                new Person("Bob", 20, Gender.MALE),
                new Person("Paula", 32, Gender.FEMALE),
                new Person("Paul", 32, Gender.MALE),
                new Person("Jack", 2, Gender.MALE),
                new Person("Jack", 72, Gender.MALE),
                new Person("Jill", 12, Gender.FEMALE)
        );
    }

    private static enum Gender {
        MALE, FEMALE
    }

    private static class Person {
        String name;
        int age;
        Gender gender;

        public Person(String name, int age, Gender gender) {
            this.name = name;
            this.age = age;
            this.gender = gender;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public Gender getGender() {
            return gender;
        }

        @Override
        public String toString() {
            return "[" + name + " " + age + " " + gender + "]";
        }
    }
}
```