
# Get a Taste of Lambdas and Get Addicted to Streams by Venkat Subramaniam

URL: https://www.youtube.com/watch?v=1OpAgZvYXLQ&t

* [What is a Lambda Expression](#what-is-a-lambda-expression)
* [Using Lambda Expressions](#Using-lambda-expression)
* [How it fits into the Java Philosophy](#how-it-fits-into-the-java-philosophy)
* [What are Lambda expressions under the hood](#what-are-lambda-expressions-under-the-hood)
* [How this is going to change the way you code](#how-this-is-going-to-change-the-way-you-code)

## What is a Lambda Expression

The following is a very noisy code:

```java
package devoxx.java8.example;

public class Sample {
    public static void main(String[] args) throws InterruptedException {
        Thread th = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("In new thread");
            }
        });
        
        th.start();
        th.join();
        System.out.println("In main");
    }
}
```

Typically a function has 4 things:

* name
* parameter list
* body
* return type

The name and the return type don't have too much value, the name can be omitted and the return type can be inferred.

## Using Lambda Expression

So a lambda expresssion only have a parameter list and body.

The above code can be made less noisy in the following way:

```java
package devoxx.java8.example;

public class Sample {
    public static void main(String[] args) throws InterruptedException {
        Thread th = new Thread(() -> System.out.println("In new thread"));

        th.start();
        th.join();
        System.out.println("In main");
    }
}
```

We have parameter list to the left of the arrow (`->`) and the body of the method to the right of the arrow.

## How it fits into the Java Philosophy

Java has a central philosophy which is "backward compatibility".
You can simply pass a lambda in the thread constructor and it will simply work. You didn't have to change anything to use it with existing APIs.

Lambdas are backed by single abstract method interfaces. (like `Runnable`, `Callable`).
You can readily use lambdas where ever you see an interface that has single abstract method.

If the users of an API are divided between Java 7 and Java 8, then the users who are on Java 8 can simply pass lambdas and the users who are on Java 7 can pass anonymous inner classes. When the users who are using Java 7 move on to Java 8, they can readily pass lambdas. This is the beauty of backward compatibility.

## What are Lambda expressions under the hood

Are Lambda expressions nothing but syntactic sugar? Thechnically the answer to this is NO.

For each anonymous inner class the compiler will create a class like `Sample$1.class` which is generated by `javac`.

`invokedynamic` (in Java 7) - you can attach and detach the function that you want to invode at runtime. This gives you a callsite of function. You can also see this as function pointers are available at runtime at the program level.

under the hood - they use `invokedynamic` to implement lambdas. The use case for `invokedynamic` was to support lambda expression. (Though in Java 7 they were supposed to support the dynamically typed languages)

The lambda expressions, though they appear as a syntactic sugar over anonymous inner classes, they don't creat any anonymous innerclass.

Benefit: 

* This reduces the memory foot-print of jar
* Lesser number of objects will be created so lesser garbage collection overhead.

So a lambda expression don't get replaced by anonymous inner classes.

When you create a lambda expression, the call to the lambda expression becomes `invokedynamic`. You can use `javap Sample.class` and see this.

Lambda expression can become one of the 3 things:

* A static method
* An instance method
* Simple routing of the invodedynamic to some other method.

## How this is going to change the way you code

Transforming iterations from imperative to functional style

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // external iterators
        /*
         * you have complete control of the iteration
         *
         * this is not generally appear to be a good thing
         * the more you control, the more you have to change what you control
         *
         * The following code is very complex
         */
        for (int i = 0; i < nums.size(); i++) {
            System.out.println(nums.get(i));
        }

        // external iterator also
        for(int e : nums) {
            System.out.println(e);
        }

        // internal iterator
        /*
         * you are calling a method on the object itself
         *
         *
         * Polymorphism:
         * You can have different implementation based on
         * the exact type of the object
         *
         * you are not passing the list of numbers to for loop,
         * rather you are calling a method on the list object.
         *
         * this method can be sequential, parallel, lazy or whatever
         * depending on the implementation
         */
        nums.forEach(new Consumer<Integer>() {
            @Override
            public void accept(Integer integer) {
                System.out.println(integer);
            }
        });

        // replacing by lambda expression
        nums.forEach((Integer e) -> System.out.println(e));

        // replacing by lambda expression and removing obvious details
        /*
         * Java 8 has type inference for lambda expression
         *
         * no paranthesis
         *
         * paranthesis is optional (only for one parameter lambdas)
         * if a lambda has no parameter at all - you need to put paranthesis
         * if a lambda has 2 or more paramteres - you need to put paranthesis
         */
        nums.forEach(e -> System.out.println(e));

        /*
         * we are receiving a value and simply calling a method
         *
         * this is a simple pass through
         *
         * method reference syntax
         */
        nums.forEach(System.out::println);
    }
}
```

Word of caution:

* To keep the lambdas cute -> don't write 20 or 50 lines of code in lambda expression
* Lambda expression should be single line of code, ideally
  * Demerits of having multiple lines of code in Lambda expression
    * Hard to read
    * Noisy
    * leads to duplication
    * hard to test (you should not have logic in a lambda)
      * you should have a function (that you can unit-test properly) and then call this function from the lambda

## A peek at method references

You are receiving an argument as paramter, and you don't want to alter the arg, then you should use method-reference.

`System.out` is an object. And `println` is not a static method, rather it's an instance method.

```java
package devoxx.java8.example;

import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;

public class Sample {
    public static void main(String[] args) throws InterruptedException {

        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        nums.stream()
                .map(String::valueOf) // passing to static method
                .forEach(System.out::println); // passing to instance method
    }
}
```